# Android アプリケーション パフォーマンス ベンチマーク スクリプト

## 技術ドキュメント

> **バージョン**: 3.0  
> **作成者**: hua.liu  
> **プラットフォーム**: macOS, Linux  
> **目的**: Android アプリケーションの実行時 CPU およびメモリパフォーマンスの測定（マルチプロセス統計対応）

---

## 目次

1. [概要](#概要)
2. [機能](#機能)
3. [システム要件](#システム要件)
4. [設定パラメータ](#設定パラメータ)
5. [CPU 収集方法](#cpu-収集方法)
6. [メモリ収集](#メモリ収集)
7. [メモリリーク検出](#メモリリーク検出)
8. [出力ファイル](#出力ファイル)
9. [技術的実装](#技術的実装)
10. [トラブルシューティング](#トラブルシューティング)

---

## 概要

本スクリプトは、動画再生やその他の高負荷操作中の Android アプリケーションの CPU およびメモリ消費を測定するための自動化パフォーマンステストツールです。**マルチプロセス統計**に対応しており、メインプロセスおよび関連するすべてのサブプロセス（サンドボックスプロセス、特権プロセス、サービスプロセスなど）のメトリクスを自動検出して集計します。

### 主な機能

- 📊 **デュアル CPU エンジン**: 2つの CPU 収集方法（`/proc/stat` と `dumpsys cpuinfo`）
- 💾 **包括的なメモリメトリクス**: PSS と RSS、PID ごとの集計対応
- 🔍 **メモリリーク検出**: 線形回帰分析によるメモリ増加傾向の検出
- 🔄 **マルチプロセス対応**: メインプロセスと子プロセスの自動検出
- 📝 **詳細レポート**: 統計分析を含む Markdown レポート
- 🌐 **インタラクティブ HTML レポート**: オプションで `report.html` を生成（チャート/テーブル、`tools/report_html.sh`）
- ⚡ **グレースフル中断**: `Ctrl+C` で収集済みデータから部分レポートを生成

---

## 機能

### 1. 依存関係チェック

スクリプトは必要なツールを自動チェックします：
- `adb` - デバイス通信用の Android Debug Bridge
- `bc` - 浮動小数点演算用のコマンドライン計算機
- `awk` - システム出力解析用のテキスト処理ツール

### 2. マルチデバイス対応

- 単一デバイス接続時は自動検出
- マルチデバイスシナリオでは `ADB_SERIAL` パラメータで手動選択
- 指定デバイスの可用性を検証

### 3. プロセス検出と管理

**マッチングパターン**: `^PACKAGE_NAME(:|_|$)`

このパターンでマッチするもの：
| プロセス名 | 説明 |
|------------|------|
| `com.xxx.yyy` | メインアプリケーションプロセス |
| `com.xxx.yyy:service` | サービスサブプロセス（コロン区切り） |
| `com.xxx.yyy:media` | メディアサブプロセス |
| `com.xxx.yyy_zygote` | Zygote 派生サブプロセス（アンダースコア区切り） |

### 4. 残留プロセスのクリーンアップ

テスト開始前に、スクリプトは：
1. パッケージ名にマッチする既存プロセスを検出
2. 待機時間を増やしながら最大3回 `force-stop` を試行
3. プロセスを終了できない場合はユーザーに確認を促す

### 5. 中断ハンドリング

- `Ctrl+C`（SIGINT）と SIGTERM シグナルのグレースフルな処理
- 中断時に収集済みデータから自動レポート生成
- 予期しない終了時のデータ損失を防止

---

## システム要件

| 要件 | 詳細 |
|------|------|
| **オペレーティングシステム** | macOS または Linux |
| **シェル** | Bash 3.2+（古い macOS と互換性あり） |
| **Android デバイス** | USB デバッグが有効 |
| **ツール** | `adb`、`bc`、`awk` |

---

## 設定パラメータ

すべての設定可能なパラメータはスクリプトの先頭にあります：

### 基本設定

| パラメータ | 型 | デフォルト値 | 説明 |
|------------|-------|--------------|------|
| `PACKAGE_NAME` | 文字列 | `com.xxx.yyy` | ターゲットアプリケーションのパッケージ名 |
| `ADB_SERIAL` | 文字列 | `""`（空） | デバイスシリアル番号（空の場合は自動検出） |
| `TEST_DURATION_MINUTES` | 整数 | `5` | テスト時間（分） |

### サンプリング設定

| パラメータ | 型 | デフォルト値 | 説明 |
|------------|-------|--------------|------|
| `CPU_INTERVAL` | 整数 | `10` | CPU サンプリング間隔（秒） |
| `MEM_INTERVAL` | 整数 | `10` | メモリサンプリング間隔（秒） |

### CPU 収集設定

| パラメータ | 型 | デフォルト値 | 説明 |
|------------|-------|--------------|------|
| `CPU_METHOD` | 文字列 | `procstat` | CPU 収集方法：`procstat` または `dumpsys` |
| `MIN_CPU_PERCENT` | 浮動小数点 | `0.0` | 有効サンプルの最小 CPU% しきい値 |
| `STRICT_WINDOW` | 整数 | `1` | WindowMs 解析の厳格性（0=緩い、1=厳格） |
| `SINGLE_CORE_DMIPS` | 整数 | `20599` | シングルコア 100% 使用率時の DMIPS 値 |

### デバッグ設定

| パラメータ | 型 | デフォルト値 | 説明 |
|------------|-------|--------------|------|
| `DEBUG_MODE` | 整数 | `0` | 詳細診断出力を有効化（0=オフ、1=オン） |

---

## CPU 収集方法

### 方法1: `/proc/stat`（推奨）

**設定**: `CPU_METHOD="procstat"`

この方法は Linux カーネルの `/proc/stat` インターフェースから生の CPU jiffies を読み取り、正確な時間ウィンドウを使用して CPU 使用率を計算します。

#### アルゴリズム

```
CPU% = 100 × NCPU × (Δプロセス_jiffies / Δシステム_jiffies)
```

ここで：
- `Δプロセス_jiffies` = マッチしたすべての PID の（現在 - 前回）CPU 時間の合計
- `Δシステム_jiffies` = システム全体の CPU 時間デルタ
- `NCPU` = オンラインの CPU コア数

#### 利点
- ✅ 正確な実時間ウィンドウ
- ✅ プロセスごとの正確な CPU アカウンティング
- ✅ 動的なプロセス作成/終了に対応
- ✅ 一貫したサンプリング間隔

#### データソース
- `/proc/stat` - システム全体の CPU 統計
- `/proc/[PID]/stat` - プロセスごとの CPU 統計
- `/sys/devices/system/cpu/online` - オンライン CPU コアの検出

---

### 方法2: `dumpsys cpuinfo`（レガシー）

**設定**: `CPU_METHOD="dumpsys"`

この方法は Android 組み込みの `dumpsys cpuinfo` コマンドを使用し、スライディング時間ウィンドウ内の CPU 使用率を報告します。

#### ウィンドウの有効性

サンプルは報告された時間ウィンドウに基づいてフィルタリングされます：
- **有効範囲**: 5000ms - 30000ms
- **短すぎる**（<5000ms）：統計から除外
- **長すぎる**（>30000ms）：統計から除外
- **不明**（-1）：`STRICT_WINDOW` 設定で制御

#### 出力解析

スクリプトはパッケージ名パターンにマッチする行を解析します：
```
12% 1234/com.xxx.yyy:service
8% 5678/com.xxx.yyy
```

---

### DMIPS 計算

両方の方法で CPU パーセンテージを DMIPS（Dhrystone Million Instructions Per Second）に変換し、デバイス間比較に使用します：

```
DMIPS = (CPU% × SINGLE_CORE_DMIPS) / 100
```

**注意**：DMIPS 値は相対比較のための近似値であり、実際のハードウェア測定値ではありません。

---

## メモリ収集

### 収集方法

スクリプトはマッチした各プロセスに対して `dumpsys meminfo [PID]` を使用し、すべてのサブプロセスで結果を集計します。

### 収集メトリクス

| メトリクス | 説明 | 用途 |
|------------|------|------|
| **PSS**（Proportional Set Size） | 共有メモリを比例配分した実際のメモリ使用量 | メモリ分析の主要メトリクス |
| **RSS**（Resident Set Size） | 共有メモリを含む物理メモリ使用量 | 二次メトリクス、重複カウントの可能性あり |

### PID ごとの集計

一部のサブプロセスを見逃す可能性がある単純な `dumpsys meminfo <package>` とは異なり、本スクリプトは：
1. パッケージパターンにマッチするすべての PID を列挙
2. 各 PID に対して個別に `dumpsys meminfo` をクエリ
3. すべてのプロセスの PSS と RSS 値を集計

これにより、`:suffix` 名を持つサブプロセスが見逃されることはありません。

---

## メモリリーク検出

### アルゴリズム

スクリプトは時間経過に伴う PSS サンプルに対して**線形回帰**を実行し、メモリ増加傾向を検出します。

### 計算式

```
傾き = (n×Σxy - Σx×Σy) / (n×Σx² - (Σx)²)
```

ここで：
- `x` = 経過時間（秒）
- `y` = PSS 値（MB）
- `n` = サンプル数

### しきい値

| 傾き（MB/秒） | 判定 |
|---------------|------|
| `> 0.005` | **リークの可能性あり**（約 300 MB/時間の増加） |
| `-0.001` ～ `0.005` | **安定**（リーク検出なし） |
| `< -0.001` | **減少**（メモリが解放されている） |

### 出力

検出結果には以下が含まれます：
- 増加率（MB/秒）
- テスト期間中の推定増加量
- 先頭から末尾へのパーセンテージ変化

---

## 出力ファイル

スクリプトは各テスト実行ごとにタイムスタンプ付きディレクトリを作成します：

```
test_YYYYMMDD_HHMMSS/
├── cpu_log.csv      # CPU サンプリングデータ
├── mem_log.csv      # メモリサンプリングデータ
└── report.md        # 総合テストレポート
```

### CPU ログ形式（`cpu_log.csv`）

| カラム | 説明 |
|--------|------|
| Timestamp | Unix タイムスタンプ |
| Time(Seconds) | テスト開始からの経過秒数 |
| CPU Percentage(%) | すべてのプロセスの集計 CPU 使用率 |
| DMIPS | 計算された DMIPS 値 |
| WindowMs | 時間ウィンドウ長（ミリ秒） |
| FilterReason | サンプル有効性ステータス |

**FilterReason の値**：
- `Valid` - サンプルは統計に含まれる
- `Baseline` - 初期キャリブレーションサンプル
- `WindowTooShort` - ウィンドウ < 5000ms（dumpsys のみ）
- `WindowTooLong` - ウィンドウ > 30000ms（dumpsys のみ）
- `WindowUnknown` - ウィンドウを解析できない
- `NoPID` - マッチするプロセスが見つからない
- `ReadFailed` - /proc/stat の読み取りに失敗

### メモリログ形式（`mem_log.csv`）

| カラム | 説明 |
|--------|------|
| Timestamp | Unix タイムスタンプ |
| Time(Seconds) | テスト開始からの経過秒数 |
| TOTAL_RSS(KB) | 合計 RSS（KB） |
| RSS(MB) | 合計 RSS（MB） |
| TOTAL_PSS(KB) | 合計 PSS（KB） |
| PSS(MB) | 合計 PSS（MB） |

### レポート形式（`report.md`）

Markdown レポートには以下が含まれます：
- テスト情報（ID、パッケージ名、期間、ステータス）
- CPU パフォーマンス統計（平均、ピーク、最小）
- メモリパフォーマンス統計（PSS と RSS）
- サンプル分析（有効/フィルタ数、フィルタ理由）
- メモリリーク検出結果

---

## 技術的実装

### 互換性機能

1. **Bash 3.2 互換**: 連想配列の代わりにファイルベースのキャッシュを使用
2. **POSIX awk**: macOS 互換性のため GNU awk 固有機能を回避
3. **クロスプラットフォーム**: macOS と Linux の両方で動作

### プロセス解析

スクリプトはさまざまな `ps` 出力形式を処理します：
- PID カラム位置を動的に識別
- `ps -A` と `ps` のバリアントを処理
- Windows スタイルの行末からキャリッジリターンを削除

### エラーハンドリング

- 開始前にすべての必須パラメータを検証
- デバイス接続と認証を確認
- テスト中のプロセス消失を処理
- 中断時のデータ損失を防止

---

## トラブルシューティング

### よくある問題

#### デバイスが検出されない

```bash
# ADB サーバーを再起動
adb kill-server && adb start-server

# デバイスで USB デバッグが有効になっているか確認
```

#### パッケージが見つからない

```bash
# パッケージ名を確認
adb shell pm list packages | grep <パッケージキーワード>

# アプリがインストールされているか確認
adb shell pm path <パッケージ名>
```

#### CPU が常に 0%

1. アプリがアクティブに実行されていることを確認（バックグラウンドではない）
2. デバイスで `/proc/stat` が読み取り可能か確認
3. `dumpsys` 方法への切り替えを試行

#### メモリ解析が失敗

1. DEBUG_MODE を有効にして生の出力を確認
2. デバイスでの `dumpsys meminfo <PID>` の形式を確認
3. 一部のデバイスは非標準の出力形式を持つ可能性あり

### デバッグモード

詳細出力を有効化：
```bash
DEBUG_MODE=1
```

以下が出力されます：
- 生の `ps` 出力と PID マッチング
- CPU jiffies 計算の詳細
- メモリ解析の中間値

---

## ライセンス

詳細は [LICENSE](LICENSE) を参照してください。

---

## 変更履歴

### バージョン 3.0
- デュアル CPU エンジンを追加（procstat + dumpsys）
- マルチプロセス検出を改善
- メモリリーク検出アルゴリズムを強化
- クロスプラットフォーム互換性を向上

---

**テスト頑張ってください！** 🚀
