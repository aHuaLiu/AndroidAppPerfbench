# Android 应用性能基准测试脚本

## 技术文档

> **版本**: 3.0  
> **作者**: hua.liu  
> **平台**: macOS, Linux  
> **用途**: 测量 Android 应用运行时的 CPU 和内存性能（支持多进程统计）

---

## 目录

1. [概述](#概述)
2. [功能特性](#功能特性)
3. [系统要求](#系统要求)
4. [配置参数](#配置参数)
5. [CPU 采集方法](#cpu-采集方法)
6. [内存采集](#内存采集)
7. [内存泄漏检测](#内存泄漏检测)
8. [输出文件](#输出文件)
9. [技术实现](#技术实现)
10. [故障排查](#故障排查)

---

## 概述

本脚本是一个自动化性能测试工具，用于测量 Android 应用在视频播放或其他高负载操作期间的 CPU 和内存消耗。它支持**多进程统计**，自动检测并聚合主进程及所有相关子进程（如沙箱进程、特权进程、服务进程等）的性能指标。

### 核心能力

- 📊 **双 CPU 引擎**: 两种 CPU 采集方法（`/proc/stat` 和 `dumpsys cpuinfo`）
- 💾 **全面的内存指标**: PSS 和 RSS，支持逐 PID 聚合
- 🔍 **内存泄漏检测**: 基于线性回归分析检测内存增长趋势
- 🔄 **多进程支持**: 自动检测主进程和子进程
- 📝 **详细报告**: Markdown 格式的统计分析报告
- 🌐 **交互式 HTML 报告**: 可选生成 `report.html`（交互图表/表格，使用 `tools/report_html.sh`）
- ⚡ **优雅中断**: `Ctrl+C` 可生成已采集数据的部分报告

---

## 功能特性

### 1. 依赖检查

脚本自动检查所需工具：
- `adb` - Android 调试桥，用于设备通信
- `bc` - 命令行计算器，用于浮点运算
- `awk` - 文本处理工具，用于解析系统输出

### 2. 多设备支持

- 单设备连接时自动检测
- 多设备场景下通过 `ADB_SERIAL` 参数手动选择
- 验证指定设备的可用性

### 3. 进程检测与管理

**匹配模式**: `^PACKAGE_NAME(:|_|$)`

此模式匹配：
| 进程名 | 说明 |
|--------|------|
| `com.xxx.yyy` | 应用主进程 |
| `com.xxx.yyy:service` | 服务子进程（冒号分隔） |
| `com.xxx.yyy:media` | 媒体子进程 |
| `com.xxx.yyy_zygote` | Zygote 派生的子进程（下划线分隔） |

### 4. 残留进程清理

测试开始前，脚本会：
1. 检测与包名匹配的现有进程
2. 尝试最多 3 次 `force-stop`，等待时间逐次递增
3. 如果进程无法终止，提示用户确认

### 5. 中断处理

- 优雅处理 `Ctrl+C`（SIGINT）和 SIGTERM 信号
- 中断时自动生成已采集数据的报告
- 防止意外终止导致数据丢失

---

## 系统要求

| 要求 | 详情 |
|------|------|
| **操作系统** | macOS 或 Linux |
| **Shell** | Bash 3.2+（兼容旧版 macOS） |
| **Android 设备** | 已启用 USB 调试 |
| **工具** | `adb`、`bc`、`awk` |

---

## 配置参数

所有可配置参数位于脚本顶部：

### 基本设置

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `PACKAGE_NAME` | 字符串 | `com.xxx.yyy` | 目标应用包名 |
| `ADB_SERIAL` | 字符串 | `""`（空） | 设备序列号（留空则自动检测） |
| `TEST_DURATION_MINUTES` | 整数 | `5` | 测试时长（分钟） |

### 采样设置

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `CPU_INTERVAL` | 整数 | `10` | CPU 采样间隔（秒） |
| `MEM_INTERVAL` | 整数 | `10` | 内存采样间隔（秒） |

### CPU 采集设置

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `CPU_METHOD` | 字符串 | `procstat` | CPU 采集方法：`procstat` 或 `dumpsys` |
| `MIN_CPU_PERCENT` | 浮点数 | `0.0` | 有效样本的最低 CPU% 阈值 |
| `STRICT_WINDOW` | 整数 | `1` | WindowMs 解析严格性（0=宽松，1=严格） |
| `SINGLE_CORE_DMIPS` | 整数 | `20599` | 单核 100% 利用率对应的 DMIPS 值 |

### 调试设置

| 参数 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| `DEBUG_MODE` | 整数 | `0` | 启用详细诊断输出（0=关闭，1=开启） |

---

## CPU 采集方法

### 方法一：`/proc/stat`（推荐）

**配置**: `CPU_METHOD="procstat"`

此方法从 Linux 内核的 `/proc/stat` 接口读取原始 CPU jiffies，使用精确的时间窗口计算 CPU 使用率。

#### 算法

```
CPU% = 100 × NCPU × (Δ进程_jiffies / Δ系统_jiffies)
```

其中：
- `Δ进程_jiffies` = 所有匹配 PID 的（当前 - 上次）CPU 时间总和
- `Δ系统_jiffies` = 系统总 CPU 时间增量
- `NCPU` = 在线 CPU 核心数

#### 优势
- ✅ 精确的实际时间窗口
- ✅ 准确的进程级 CPU 计量
- ✅ 处理动态进程创建/终止
- ✅ 一致的采样间隔

#### 数据来源
- `/proc/stat` - 系统级 CPU 统计
- `/proc/[PID]/stat` - 进程级 CPU 统计
- `/sys/devices/system/cpu/online` - 在线 CPU 核心检测

---

### 方法二：`dumpsys cpuinfo`（传统方法）

**配置**: `CPU_METHOD="dumpsys"`

此方法使用 Android 内置的 `dumpsys cpuinfo` 命令，报告滑动时间窗口内的 CPU 使用率。

#### 窗口有效性

样本根据报告的时间窗口进行过滤：
- **有效范围**: 5000ms - 30000ms
- **过短**（<5000ms）：从统计中排除
- **过长**（>30000ms）：从统计中排除
- **未知**（-1）：由 `STRICT_WINDOW` 设置控制

#### 输出解析

脚本解析匹配包名模式的行：
```
12% 1234/com.xxx.yyy:service
8% 5678/com.xxx.yyy
```

---

### DMIPS 计算

两种方法都将 CPU 百分比转换为 DMIPS（Dhrystone 每秒百万指令），用于跨设备比较：

```
DMIPS = (CPU% × SINGLE_CORE_DMIPS) / 100
```

**注意**：DMIPS 值是用于相对比较的近似值，不是实际硬件测量值。

---

## 内存采集

### 采集方法

脚本对每个匹配的进程使用 `dumpsys meminfo [PID]`，跨所有子进程聚合结果。

### 采集指标

| 指标 | 说明 | 用途 |
|------|------|------|
| **PSS**（比例集大小） | 实际内存使用量，按比例分摊共享内存 | 内存分析的主要指标 |
| **RSS**（常驻集大小） | 物理内存使用量，包含共享内存 | 次要指标，可能重复计算 |

### 逐 PID 聚合

与简单的 `dumpsys meminfo <package>` 可能遗漏某些子进程不同，本脚本：
1. 枚举所有匹配包名模式的 PID
2. 为每个 PID 单独查询 `dumpsys meminfo`
3. 聚合所有进程的 PSS 和 RSS 值

这确保了带 `:suffix` 命名的子进程不会被遗漏。

---

## 内存泄漏检测

### 算法

脚本对随时间采集的 PSS 样本进行**线性回归**，检测内存增长趋势。

### 计算公式

```
斜率 = (n×Σxy - Σx×Σy) / (n×Σx² - (Σx)²)
```

其中：
- `x` = 经过时间（秒）
- `y` = PSS 值（MB）
- `n` = 样本数

### 阈值

| 斜率（MB/秒） | 判定 |
|---------------|------|
| `> 0.005` | **可能泄漏**（约 300 MB/小时增长） |
| `-0.001` 至 `0.005` | **稳定**（未检测到泄漏） |
| `< -0.001` | **下降**（内存正在释放） |

### 输出

检测结果包括：
- 增长率（MB/秒）
- 测试期间估计增长量
- 首尾百分比变化

---

## 输出文件

脚本为每次测试运行创建带时间戳的目录：

```
test_YYYYMMDD_HHMMSS/
├── cpu_log.csv      # CPU 采样数据
├── mem_log.csv      # 内存采样数据
└── report.md        # 综合测试报告
```

### CPU 日志格式（`cpu_log.csv`）

| 列 | 说明 |
|----|------|
| Timestamp | Unix 时间戳 |
| Time(Seconds) | 测试开始后的经过秒数 |
| CPU Percentage(%) | 所有进程的聚合 CPU 使用率 |
| DMIPS | 计算的 DMIPS 值 |
| WindowMs | 时间窗口长度（毫秒） |
| FilterReason | 样本有效性状态 |

**FilterReason 值**：
- `Valid` - 样本包含在统计中
- `Baseline` - 初始校准样本
- `WindowTooShort` - 窗口 < 5000ms（仅 dumpsys）
- `WindowTooLong` - 窗口 > 30000ms（仅 dumpsys）
- `WindowUnknown` - 无法解析窗口
- `NoPID` - 未找到匹配进程
- `ReadFailed` - 读取 /proc/stat 失败

### 内存日志格式（`mem_log.csv`）

| 列 | 说明 |
|----|------|
| Timestamp | Unix 时间戳 |
| Time(Seconds) | 测试开始后的经过秒数 |
| TOTAL_RSS(KB) | 总 RSS（KB） |
| RSS(MB) | 总 RSS（MB） |
| TOTAL_PSS(KB) | 总 PSS（KB） |
| PSS(MB) | 总 PSS（MB） |

### 报告格式（`report.md`）

Markdown 报告包含：
- 测试信息（ID、包名、时长、状态）
- CPU 性能统计（平均值、峰值、最小值）
- 内存性能统计（PSS 和 RSS）
- 样本分析（有效/过滤计数、过滤原因）
- 内存泄漏检测结果

---

## 技术实现

### 兼容性特性

1. **Bash 3.2 兼容**: 使用基于文件的缓存替代关联数组
2. **POSIX awk**: 避免 GNU awk 特有功能，确保 macOS 兼容性
3. **跨平台**: 支持 macOS 和 Linux

### 进程解析

脚本处理各种 `ps` 输出格式：
- 动态识别 PID 列位置
- 处理 `ps -A` 和 `ps` 变体
- 去除 Windows 风格换行符的回车

### 错误处理

- 启动前验证所有必需参数
- 检查设备连接和授权
- 处理测试期间进程消失
- 防止中断时数据丢失

---

## 故障排查

### 常见问题

#### 未检测到设备

```bash
# 重启 ADB 服务器
adb kill-server && adb start-server

# 检查设备上是否启用了 USB 调试
```

#### 找不到包名

```bash
# 验证包名
adb shell pm list packages | grep <包名关键词>

# 检查应用是否已安装
adb shell pm path <包名>
```

#### CPU 始终为 0%

1. 确保应用正在活跃运行（非后台）
2. 检查设备上 `/proc/stat` 是否可读
3. 尝试切换到 `dumpsys` 方法

#### 内存解析失败

1. 启用 DEBUG_MODE 查看原始输出
2. 检查设备上 `dumpsys meminfo <PID>` 的格式
3. 某些设备可能有非标准输出格式

### 调试模式

启用详细输出：
```bash
DEBUG_MODE=1
```

这将打印：
- 原始 `ps` 输出和 PID 匹配
- CPU jiffies 计算详情
- 内存解析中间值

---

## 许可证

详见 [LICENSE](LICENSE)。

---

## 更新日志

### 版本 3.0
- 新增双 CPU 引擎（procstat + dumpsys）
- 改进多进程检测
- 增强内存泄漏检测算法
- 更好的跨平台兼容性

---

**祝测试顺利！** 🚀
