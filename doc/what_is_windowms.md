# WindowMsとは？

**WindowMs** は **時間ウィンドウの長さ**（単位：ミリ秒）で、今回のCPU使用率統計がカバーする時間範囲を表します。

## 一、なぜ時間ウィンドウが必要なのか？

CPU使用率は瞬間的な値ではなく、**一定期間内の平均値**です。「今の速度はいくらか」とは言えず、「過去10秒間の平均速度は毎秒5メートル」と言う必要があるのと同じです。

CPU使用率の計算には以下が必要です：
1. 開始時点のCPU動作時間を記録
2. 終了時点のCPU動作時間を記録
3. この期間内にCPUがどれだけ動作したかを計算

**WindowMs は、この「開始点から終了点まで」の時間長です。**

## 二、具体例

### 例1：10秒の時間ウィンドウ

```
現在時刻：15:30:20（現在の時間）
WindowMs = 10000（10秒 = 10000ミリ秒）

統計の時間範囲：
- 開始点：15:30:10（10秒前）
- 終了点：15:30:20（今）
- ウィンドウ長：10秒

得られたCPU使用率：アプリがこの10秒間に平均25%のCPUを占有
```

### 例2：5秒の時間ウィンドウ

```
現在時刻：15:30:20
WindowMs = 5000（5秒）

統計の時間範囲：
- 開始点：15:30:15（5秒前）
- 終了点：15:30:20（今）
- ウィンドウ長：5秒

得られたCPU使用率：アプリがこの5秒間に平均30%のCPUを占有
```

**注意**：同じアプリでも、5秒ウィンドウと10秒ウィンドウで測定されたCPU使用率は異なる可能性があります。統計期間が異なるためです。

## 三、dumpsysの出力例

`adb shell dumpsys cpuinfo` を実行すると、次のような出力が表示されます：

```
CPU usage from 8234ms to 234ms ago (6.8 secs):
  25% 12345/com.xxx.yyy: 20% user + 5% kernel
  ...
```

ここで：
- `8234ms ago` = 8234ミリ秒前（開始点）
- `234ms ago` = 234ミリ秒前（終了点）
- **WindowMs = 8234 - 234 = 8000 ミリ秒 = 8秒**

これは：8秒前から234ミリ秒前までの期間のCPU使用率を統計したことを示します。

## 四、時間ウィンドウの長短による影響

### ウィンドウが短すぎる場合（例：1秒）
- **利点**：CPU使用率の変化に迅速に反応できる
- **欠点**：データの変動が大きく、不安定
- **例**：アプリが特定の1秒間にたまたま複雑な計算をしていて90%と表示されるが、実際にはほとんどの時間20%しか使っていない

### ウィンドウが長すぎる場合（例：60秒）
- **利点**：データが滑らかで安定
- **欠点**：反応が遅く、短時間のピークを見逃す
- **例**：アプリが最初の1秒で100%のCPUを使用したが、その後59秒は10%だった場合、平均すると11.5%としか表示されない

### 適切なウィンドウ（5-30秒）
- CPU使用のトレンドを確認できる
- 短期的な変動に邪魔されない
- **このスクリプトの有効範囲は 5000-30000 ミリ秒（5-30秒）**

## 五、このスクリプトでの役割

このスクリプトには2つのCPU測定方法があります：

### 方法1：dumpsys（スライディングウィンドウ）
- システムが WindowMs を決定し、通常5-30秒の間で変動
- スクリプトはこの値を解析し、5000-30000msのサンプルのみを受け入れる
- WindowMs = -1 は解析失敗を示す（時間ウィンドウを確定できない）

### 方法2：procstat（固定ウィンドウ）
- スクリプト自身が時間ウィンドウを制御 = CPU_INTERVAL（デフォルト10秒）
- WindowMs は実際に経過した時間 × 1000（ミリ秒に変換）
- ベースラインサンプルの WindowMs = 0（統計には含まれない）

## 六、STRICT_WINDOW パラメータ

```bash
STRICT_WINDOW=1  # 厳格モード：WindowMs=-1 のサンプルを除外
STRICT_WINDOW=0  # 寛容モード：WindowMs=-1 のサンプルを許可（リスクあり）
```

- **WindowMs=-1** の意味：スクリプトが時間ウィンドウの長さを解析できず、このCPUデータが何秒間統計されたかわからない
- **厳格モード（推奨）**：これらの不確実なデータを除外し、結果の信頼性を保証
- **寛容モード**：これらのデータを保持するが、精度に影響する可能性がある

## 七、実際のデータ例

生成される `cpu_log.csv` ファイルで、WindowMs は第5列です：

```csv
Timestamp,Time(Seconds),CPU Percentage(%),DMIPS,WindowMs,FilterReason
1705789200,0,0.00,0,0,Baseline
1705789210,10,25.34,5215,10000,Valid
1705789220,20,28.16,5801,10000,Valid
1705789230,30,22.89,4715,10000,Valid
```

解釈：
- 1行目（Baseline）：WindowMs=0、ベースラインサンプル、統計には含まれない
- 2-4行目：WindowMs=10000ms（10秒）、これらは有効なサンプル
- FilterReason はサンプル状態を示す：Valid（有効）、Baseline（ベースライン）、WindowTooShort（ウィンドウが短すぎる）など

## 八、よくある質問

### Q1: なぜ WindowMs がちょうど 10000ms ではないのですか？

**A:** dumpsys 方法の場合、WindowMs は Android システムが決定するため、変動があります。procstat 方法の WindowMs のみが設定された CPU_INTERVAL に近い値になります。

### Q2: WindowMs=-1 とはどういう意味ですか？

**A:** スクリプトが dumpsys 出力から時間ウィンドウ情報を解析できなかったことを示します。考えられる原因：
- dumpsys 出力フォーマットが標準でない
- Android システムバージョンの違い
- データ解析の失敗

### Q3: なぜウィンドウが短すぎる、または長すぎるサンプルを除外するのですか？

**A:** 
- **短すぎる**（<5秒）：データが不安定で、瞬間的な変動の影響を受けやすい
- **長すぎる**（>30秒）：反応が遅すぎて、実際のパフォーマンス変化を反映できない
- **適切な範囲**（5-30秒）：安定性と感度のバランスが取れている

### Q4: procstat 方法の WindowMs がなぜより正確なのですか？

**A:** procstat 方法はスクリプト自身が制御する時計を使用します：
```bash
wall_prev=$(前回のサンプリング時刻)
wall_now=$(現在時刻)
WindowMs = (wall_now - wall_prev) × 1000
```
このように計算されたウィンドウ長は実際に経過した時間であり、より信頼性が高いです。

**関連ドキュメント**：
- [スクリプト機能説明（英語）](what_can_I_do.md)
- [スクリプト機能説明（中国語）](what_can_I_do_cn.md)
- [スクリプト機能説明（日本語）](what_can_I_do_ja.md)
- [WindowMs説明（中国語）](WindowMs説明.md)
